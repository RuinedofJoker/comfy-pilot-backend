# Tool 模块 - 模块设计

## 1. 模块概述

### 1.1 模块定位
Tool 模块为 Agent 提供符合 langchain4j 规范的工具集，工具的调用由 langchain4j 框架管理，Tool 模块负责提供工具实例和注册管理。

### 1.2 核心职责
- 提供符合 langchain4j `@Tool` 注解规范的工具类
- 管理工具的注册和查找（ToolRegistry）
- 为 Agent 构建时提供工具实例
- 封装底层模型能力为 langchain4j 工具方法

### 1.3 设计原则
- **langchain4j 优先**：所有工具必须符合 langchain4j 的 `@Tool` 注解规范
- **框架托管执行**：工具调用由 langchain4j 框架管理，不自行实现执行器
- **工具即能力**：每个 Tool 类封装一组相关能力
- **Spring 集成**：工具类作为 Spring Bean，便于依赖注入
- **可扩展性**：易于添加新的工具类型

---

## 2. 架构设计

### 2.1 整体架构

```
┌─────────────────────────────────────────────────────────┐
│                    Agent Layer (Agent层)                 │
│              使用 langchain4j AiServices                 │
└────────────────────┬────────────────────────────────────┘
                     │
                     ↓ 构建时注入工具
┌─────────────────────────────────────────────────────────┐
│                  Tool Layer (工具层)                      │
│  ┌─────────────────────────────────────────────────┐   │
│  │  1. Tool 实现层                                  │   │
│  │     - WorkflowTool (工作流操作)                 │   │
│  │     - LlmTool (LLM调用)                         │   │
│  │     - 每个方法使用 @Tool 注解                    │   │
│  └─────────────────────────────────────────────────┘   │
│  ┌─────────────────────────────────────────────────┐   │
│  │  2. Tool 管理层                                  │   │
│  │     - ToolRegistry (工具注册和查找)             │   │
│  │     - 为 Agent 提供工具实例                      │   │
│  └─────────────────────────────────────────────────┘   │
└────────────────────┬────────────────────────────────────┘
                     │
                     ↓ 调用底层服务
┌─────────────────────────────────────────────────────────┐
│          Model/Workflow/Resource Layer                   │
│     ModelCapabilityService / WorkflowService             │
└─────────────────────────────────────────────────────────┘
```

**重要说明**：
- 工具调用由 langchain4j 框架管理，不需要 ToolExecutor
- Agent 在构建时通过 ToolRegistry 获取工具实例
- langchain4j 会自动识别 `@Tool` 注解的方法并在需要时调用

### 2.2 调用流程

```
1. Agent 构建阶段：
   Agent 实现类
     ↓ 通过 ToolRegistry 获取工具实例
   ToolRegistry
     ↓ 返回工具实例列表
   AiServices.builder()
     ↓ .tools(toolInstances)
   构建完成的 Agent

2. Agent 执行阶段（由 langchain4j 管理）：
   用户输入
     ↓ Agent.execute()
   langchain4j 框架
     ↓ 分析是否需要调用工具
   自动调用 @Tool 注解的方法
     ↓ 执行工具逻辑
   Tool 方法内部调用底层服务
     ↓ 返回结果
   langchain4j 框架
     ↓ 整合结果生成最终响应
   返回给用户
```

**关键点**：
- 工具调用完全由 langchain4j 框架管理
- Tool 类只需提供带 `@Tool` 注解的方法
- 不需要自己实现工具选择和执行逻辑

---

## 3. 核心组件

### 3.1 Tool 类（langchain4j 工具）

**职责**：提供符合 langchain4j 规范的工具方法

**实现规范**：
- 使用 `@Component` 注解，作为 Spring Bean
- 工具方法使用 `@Tool` 注解标记
- 方法参数使用 `@P` 注解描述参数含义
- 方法返回值为简单类型或 POJO

**示例代码**：
```java
@Component
public class WorkflowTool {

    @Autowired
    private WorkflowService workflowService;

    @Tool("创建一个新的ComfyUI工作流")
    public String createWorkflow(
            @P("工作流名称") String name,
            @P("工作流描述") String description) {

        Workflow workflow = workflowService.create(name, description);
        return "工作流创建成功，ID: " + workflow.getId();
    }

    @Tool("查询工作流详情")
    public String getWorkflow(@P("工作流ID") Long workflowId) {
        Workflow workflow = workflowService.getById(workflowId);
        return workflow.toString();
    }
}
```

### 3.2 ToolRegistry

**职责**：工具注册中心，为 Agent 构建提供工具实例

**核心功能**：
- 自动注册所有 Tool Bean（通过 ApplicationContextAware）
- 按类型查找工具实例
- 按名称查找工具实例
- 获取所有工具实例列表
- 为 Agent 提供工具实例数组

**示例代码**：
```java
@Component
public class ToolRegistry implements ApplicationContextAware {

    private final Map<String, Object> toolMap = new ConcurrentHashMap<>();

    @Override
    public void setApplicationContext(ApplicationContext context) {
        // 自动注册所有带 @Tool 注解方法的 Bean
        Map<String, Object> beans = context.getBeansWithAnnotation(Component.class);
        for (Object bean : beans.values()) {
            if (hasToolMethods(bean)) {
                toolMap.put(bean.getClass().getSimpleName(), bean);
            }
        }
    }

    public Object[] getAllTools() {
        return toolMap.values().toArray();
    }

    public Object getToolByName(String name) {
        return toolMap.get(name);
    }
}
```

---

## 4. Agent 使用工具示例

### 4.1 在 Agent 中集成工具

**示例：WorkflowAgent 使用 WorkflowTool**

```java
@Component
public class WorkflowAgent implements Agent {

    @Autowired
    private ToolRegistry toolRegistry;

    @Autowired
    private ChatLanguageModel chatModel;

    private Assistant assistant;

    @PostConstruct
    public void init() {
        // 从 ToolRegistry 获取工具实例
        Object[] tools = toolRegistry.getAllTools();

        // 使用 langchain4j 构建 Agent
        this.assistant = AiServices.builder(Assistant.class)
                .chatLanguageModel(chatModel)
                .tools(tools)  // 注入工具
                .build();
    }

    @Override
    public AgentExecutionResponse execute(AgentExecutionRequest request) {
        String response = assistant.chat(request.getInput());
        return AgentExecutionResponse.success(response);
    }

    // langchain4j 接口定义
    interface Assistant {
        @SystemMessage("你是一个ComfyUI工作流编辑助手")
        String chat(@UserMessage String message);
    }
}
```

---

## 5. 工具类型

### 5.1 已实现工具

#### WorkflowTool - 工作流操作工具
- **能力**：创建、查询、更新、删除工作流
- **方法**：
  - `createWorkflow(name, description)` - 创建工作流
  - `getWorkflow(workflowId)` - 查询工作流
  - `updateWorkflow(workflowId, updates)` - 更新工作流
  - `deleteWorkflow(workflowId)` - 删除工作流

#### LlmTool - 大语言模型工具
- **能力**：调用LLM进行文本生成
- **方法**：
  - `generateText(prompt, temperature, maxTokens)` - 生成文本
  - `chat(message)` - 对话交互

### 5.2 预留工具类型

- **ResourceTool** - 资源管理工具（文件上传、下载）
- **EmbeddingTool** - 向量生成工具（文本向量化）
- **RagTool** - RAG检索工具（知识库检索）

---

## 6. 工具开发规范

### 6.1 工具方法签名规范

**参数规范**：
- 使用 `@P` 注解描述每个参数
- 参数类型应为简单类型（String、Long、Integer、Boolean等）或简单POJO
- 避免使用复杂的嵌套对象

**返回值规范**：
- 返回 String 类型（最常用，langchain4j会自动处理）
- 返回简单 POJO（会被序列化为JSON）
- 避免返回复杂对象或流式数据

**异常处理**：
- 工具方法内部应捕获异常并返回友好的错误信息
- 不要抛出未捕获的异常，会导致Agent执行失败

---

## 7. 依赖关系

### 7.1 依赖的模块
- **Model 模块**：LlmTool 调用 ModelCapabilityService
- **Workflow 模块**：WorkflowTool 调用 WorkflowService
- **Resource 模块**：ResourceTool 调用 FileUploadService

### 7.2 被依赖的模块
- **Agent 模块**：Agent 通过 ToolRegistry 获取工具实例

---

## 8. 扩展性设计

### 8.1 添加新工具

**步骤**：
1. 创建新的工具类，添加 `@Component` 注解
2. 注入需要的服务依赖
3. 编写工具方法，使用 `@Tool` 和 `@P` 注解
4. 重启应用，ToolRegistry 自动注册
5. Agent 可以立即使用新工具

---

## 9. 设计优势

### 9.1 框架集成
- 完全符合 langchain4j 规范
- 工具调用由框架自动管理
- 无需手动实现工具选择和执行逻辑

### 9.2 开发简单
- 只需编写带 `@Tool` 注解的方法
- 自动注册，无需手动配置
- 易于测试和维护

### 9.3 可扩展性
- 易于添加新工具
- 工具之间相互独立
- 支持依赖注入

### 9.4 类型安全
- 编译时类型检查
- IDE 自动补全支持
- 减少运行时错误

---
